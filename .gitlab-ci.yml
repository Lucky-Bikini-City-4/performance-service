# 사용할 도커 이미지
image: openjdk:17-jdk-slim

# 파이프라인에 사용될 변수들
variables:
  BUILD_DIR: 'build/libs'
  ARTIFACT_NAME: 'performance-service-build.jar'

stages:
  - build
  - test
  - deploy

# 빌드 (Build) 단계
build:
  stage: build
  tags:
    - aws-ubuntu-docker
  script:
    - echo "Building the project..."
    - mkdir -p src/main/resources
    - echo "$APPLICATION_YML" > src/main/resources/application.yml
    - cp src/main/resources/application.yml ./application.yml
    - chmod +x gradlew
    - ./gradlew clean build -x test
    - echo "Build complete."
  artifacts:
    paths:
      - build/libs/performance-service-build.jar
      - application.yml
    expire_in: 1 hour
  only:
    - main
    - dev

# 테스트 (Test) 단계
test:
  stage: test
  tags:
    - aws-ubuntu-docker
  services:
    - redis:6-alpine  # 테스트용 Redis 서비스
  variables:
    REDIS_URL: "redis://redis:6379"
  script:
    - echo "Running tests..."
    - mkdir -p src/main/resources

    # 테스트용 application-test.yml 생성
    - |
      cat > src/main/resources/application-test.yml << 'EOF'
      spring:
        application:
          name: performance-service
        datasource:
          url: jdbc:h2:mem:testdb;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
          username: sa
          password: 
          driver-class-name: org.h2.Driver
        h2:
          console:
            enabled: true
        jpa:
          hibernate:
            ddl-auto: create-drop
          show-sql: false
          properties:
            hibernate:
              format_sql: false
              dialect: org.hibernate.dialect.H2Dialect
        data:
          redis:
            host: redis
            port: 6379
            timeout: 2000ms
        cache:
          type: simple
        kafka:
          bootstrap-servers: localhost:9093
      redisson:
        lock:
          wait-time: 1000
          lease-time: 2000
      server:
        port: 0
      eureka:
        client:
          enabled: false
      springdoc:
        swagger-ui:
          enabled: false
        api-docs:
          enabled: false
      logging:
        level:
          org.springframework: WARN
          com.dayaeyak.performance: INFO
      EOF

    - chmod +x gradlew
    # 테스트 프로파일로 테스트 실행
    - ./gradlew test -Dspring.profiles.active=test
    - echo "All tests passed."
  dependencies:
    - build
  only:
    - main
    - dev

deploy:
  stage: deploy
  image: docker:24.0.5
  services:
    - name: docker:24.0.5-dind
      alias: docker
  variables:
    DOCKER_TLS_CERTDIR: ""
    DOCKER_HOST: tcp://docker:2375
  tags:
    - aws-ubuntu-docker
  dependencies:
    - build
  before_script:
    - set -o errexit -o nounset -o pipefail
    - docker info
    # 아티팩트 다운로드 상태 확인
    - echo "=== Checking downloaded artifacts ==="
    - pwd
    - ls -la
    - find . -name "*.jar" -type f || echo "No JAR files found"
    - find . -name "application.yml" -type f || echo "No application.yml found"
  script:
    - echo "Starting deployment process..."

    # 1) 아티팩트 파일 존재 확인 및 복사
    - |
      if [ -f "build/libs/performance-service-build.jar" ]; then
        echo "Found JAR at expected location"
        cp build/libs/performance-service-build.jar ./performance-service-build.jar
      elif [ -f "performance-service-build.jar" ]; then
        echo "Found JAR in root directory"
        # 이미 루트에 있으므로 복사 불필요
      else
        echo "Searching for JAR file..."
        JAR_FILE=$(find . -name "*.jar" -type f | head -1)
        if [ -n "$JAR_FILE" ]; then
          echo "Found JAR file: $JAR_FILE"
          cp "$JAR_FILE" ./performance-service-build.jar
        else
          echo "ERROR: No JAR file found!" >&2
          exit 1
        fi
      fi

    # 2) application.yml 파일 확인
    - |
      if [ ! -f "application.yml" ]; then
        echo "ERROR: application.yml not found!" >&2
        exit 1
      fi

    # 3) 최종 파일 확인
    - echo "=== Final files check ==="
    - ls -la performance-service-build.jar application.yml

    # 4) Docker 이미지 빌드
    - docker build -t "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA" .

    # 5) GitLab 레지스트리 로그인 및 푸시
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
    - docker push "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"

    # 6) SSH 클라이언트 설치
    - |
      if command -v apk >/dev/null 2>&1; then
        apk add --no-cache openssh-client
      elif command -v apt-get >/dev/null 2>&1; then
        apt-get update && apt-get install -y openssh-client
      else
        echo "No supported package manager to install ssh client" >&2
        exit 1
      fi

    # EC2 키 파일 생성 (File 변수 그대로)
    - echo "=== Checking EC2 private key ==="
    - ls -l "$EC2_PRIVATE_KEY"
    - cat "$EC2_PRIVATE_KEY" | head -5
    - mv "$EC2_PRIVATE_KEY" deploy_key.pem
    - chmod 600 deploy_key.pem
    - ls -l deploy_key.pem


    # 8) 원격 배포 실행 - 직접 치환 방식 (더 간단함)
    - >
      ssh -o StrictHostKeyChecking=no -i deploy_key.pem "$EC2_USER@$EC2_HOST" "
        echo 'Logging into registry...' &&
        echo '$CI_REGISTRY_PASSWORD' | docker login -u '$CI_REGISTRY_USER' --password-stdin '$CI_REGISTRY' &&
        echo 'Pulling image: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA' &&
        docker pull '$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA' &&
        echo 'Deploying with docker-compose...' &&
        export CI_REGISTRY_IMAGE='$CI_REGISTRY_IMAGE' &&
        export CI_COMMIT_SHORT_SHA='$CI_COMMIT_SHORT_SHA' &&
        if command -v docker-compose >/dev/null 2>&1; then
          docker-compose -f /home/$EC2_USER/docker-compose.yml down &&
          docker-compose -f /home/$EC2_USER/docker-compose.yml up -d
        elif docker compose version >/dev/null 2>&1; then
          docker compose -f /home/$EC2_USER/docker-compose.yml down &&
          docker compose -f /home/$EC2_USER/docker-compose.yml up -d
        else
          echo 'No docker-compose or docker compose found' >&2
          exit 1
        fi &&
        echo 'Deployment completed successfully'
      "

    # 9) 정리
    - rm -f deploy_key.pem
    - echo "Deployment successful."
  only:
    - main