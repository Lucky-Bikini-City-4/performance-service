# 사용할 도커 이미지
image: openjdk:17-jdk-slim

# 파이프라인에 사용될 변수들
variables:
  BUILD_DIR: 'build/libs'
  ARTIFACT_NAME: 'performance-service-build.jar'

stages:
  - build
  - test
  - deploy

# 빌드 (Build) 단계
build:
  stage: build
  tags:
    - aws-ubuntu-docker
  script:
    - echo "Building the project..."
    - mkdir -p src/main/resources
    - echo "$APPLICATION_YML" > src/main/resources/application.yml
    - cp src/main/resources/application.yml ./application.yml
    - chmod +x gradlew
    - ./gradlew clean build -x test
    - echo "Build complete."
  artifacts:
    paths:
      - build/libs/performance-service-build.jar
      - application.yml
    expire_in: 1 hour
  only:
    - main
    - dev

# 테스트 (Test) 단계
test:
  stage: test
  tags:
    - aws-ubuntu-docker
  services:
    - redis:6-alpine  # 테스트용 Redis 서비스
  variables:
    REDIS_URL: "redis://redis:6379"
  script:
    - echo "Running tests..."
    - mkdir -p src/main/resources

    # 테스트용 application-test.yml 생성
    - |
      cat > src/main/resources/application-test.yml << 'EOF'
      spring:
        application:
          name: performance-service
        datasource:
          url: jdbc:h2:mem:testdb;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
          username: sa
          password: 
          driver-class-name: org.h2.Driver
        h2:
          console:
            enabled: true
        jpa:
          hibernate:
            ddl-auto: create-drop
          show-sql: false
          properties:
            hibernate:
              format_sql: false
              dialect: org.hibernate.dialect.H2Dialect
        data:
          redis:
            host: redis
            port: 6379
            timeout: 2000ms
        cache:
          type: simple
        kafka:
          bootstrap-servers: localhost:9093
      redisson:
        lock:
          wait-time: 1000
          lease-time: 2000
      server:
        port: 0
      eureka:
        client:
          enabled: false
      springdoc:
        swagger-ui:
          enabled: false
        api-docs:
          enabled: false
      logging:
        level:
          org.springframework: WARN
          com.dayaeyak.performance: INFO
      EOF

    - chmod +x gradlew
    # 테스트 프로파일로 테스트 실행
    - ./gradlew test -Dspring.profiles.active=test
    - echo "All tests passed."
  dependencies:
    - build
  only:
    - main
    - dev

deploy:
  stage: deploy
  image: docker:24.0.5
  services:
    - name: docker:24.0.5-dind
      alias: docker
  variables:
    DOCKER_TLS_CERTDIR: ""     # TLS 비활성화
    DOCKER_HOST: tcp://docker:2375
  tags:
    - aws-ubuntu-docker
  dependencies:
    - build
  before_script:
    - set -o errexit -o nounset -o pipefail
    - docker info
  script:
    - echo "Starting deployment process..."

    # 1) 빌드된 JAR 파일을 Docker 컨텍스트로 이동
    - cp "$BUILD_DIR/$ARTIFACT_NAME" ./performance-service-build.jar

    # 2) Docker 이미지 빌드
    - docker build -t "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA" .

    # 3) GitLab 레지스트리 로그인
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"

    # 4) 이미지 pull (실패 시 배포 중단)
    - docker pull "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"

    # 5) SSH/scp 클라이언트 설치
    - |
      if command -v apk >/dev/null 2>&1; then
        apk add --no-cache openssh-client
      elif command -v apt-get >/dev/null 2>&1; then
        apt-get update && apt-get install -y openssh-client
      else
        echo "No supported package manager to install ssh client" >&2
        exit 1
      fi

    # 6) EC2 키 파일 생성
    - printf '%s\n' "$EC2_PRIVATE_KEY" | sed 's/\r$//' > deploy_key.pem
    - chmod 600 deploy_key.pem

    # 7) 원격에서 안전하게 배포 실행
    - >
      ssh -o StrictHostKeyChecking=no -i deploy_key.pem "$EC2_USER@$EC2_HOST" "
        echo '$CI_REGISTRY_PASSWORD' | docker login -u '$CI_REGISTRY_USER' --password-stdin $CI_REGISTRY &&
        docker pull $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA &&
        if command -v docker-compose >/dev/null 2>&1; then
          docker-compose -f /home/$EC2_USER/docker-compose.yml down &&
          docker-compose -f /home/$EC2_USER/docker-compose.yml up -d;
        elif docker compose version >/dev/null 2>&1; then
          docker compose -f /home/$EC2_USER/docker-compose.yml down &&
          docker compose -f /home/$EC2_USER/docker-compose.yml up -d;
        else
          echo 'No docker-compose or docker compose on remote host' >&2
          exit 1
        fi
      "

    # 8) 민감 파일 정리
    - rm -f deploy_key.pem
    - echo "Deployment successful."
  only:
    - main

