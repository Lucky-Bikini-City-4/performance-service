# 사용할 도커 이미지
image: openjdk:17-jdk-slim

# 파이프라인에 사용될 변수들
variables:
  BUILD_DIR: 'build/libs'
  ARTIFACT_NAME: 'performance-service-build.jar'

stages:
  - build
  - test
  - deploy

# 빌드 (Build) 단계
build:
  stage: build
  tags:
    - aws-ubuntu-docker
  script:
    - echo "Building the project..."
    - mkdir -p src/main/resources
    - echo "$APPLICATION_YML" > src/main/resources/application.yml
    - cp src/main/resources/application.yml ./application.yml
    - chmod +x gradlew
    - ./gradlew clean build -x test
    - echo "Build complete."
    # 빌드 완료 후 파일 확인
    - ls -la build/libs/
    - find build/libs/ -name "*.jar" -type f
  artifacts:
    paths:
      - build/libs/*.jar  # 모든 jar 파일 포함
      - application.yml
    expire_in: 1 hour
  only:
    - main
    - dev

# 테스트 (Test) 단계
test:
  stage: test
  tags:
    - aws-ubuntu-docker
  services:
    - redis:6-alpine  # 테스트용 Redis 서비스
  variables:
    REDIS_URL: "redis://redis:6379"
  script:
    - echo "Running tests..."
    - mkdir -p src/main/resources

    # 테스트용 application-test.yml 생성
    - |
      cat > src/main/resources/application-test.yml << 'EOF'
      spring:
        application:
          name: performance-service
        datasource:
          url: jdbc:h2:mem:testdb;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
          username: sa
          password: 
          driver-class-name: org.h2.Driver
        h2:
          console:
            enabled: true
        jpa:
          hibernate:
            ddl-auto: create-drop
          show-sql: false
          properties:
            hibernate:
              format_sql: false
              dialect: org.hibernate.dialect.H2Dialect
        data:
          redis:
            host: redis
            port: 6379
            timeout: 2000ms
        cache:
          type: simple
        kafka:
          bootstrap-servers: localhost:9093
      redisson:
        lock:
          wait-time: 1000
          lease-time: 2000
      server:
        port: 0
      eureka:
        client:
          enabled: false
      springdoc:
        swagger-ui:
          enabled: false
        api-docs:
          enabled: false
      logging:
        level:
          org.springframework: WARN
          com.dayaeyak.performance: INFO
      EOF

    - chmod +x gradlew
    # 테스트 프로파일로 테스트 실행
    - ./gradlew test -Dspring.profiles.active=test
    - echo "All tests passed."
  dependencies:
    - build
  only:
    - main
    - dev

deploy:
  stage: deploy
  image: docker:24.0.5
  services:
    - name: docker:24.0.5-dind
      alias: docker
  variables:
    DOCKER_TLS_CERTDIR: ""
    DOCKER_HOST: tcp://docker:2375
  tags:
    - aws-ubuntu-docker
  dependencies:
    - build
  before_script:
    - set -o errexit -o nounset -o pipefail
    - docker info
    # 아티팩트 다운로드 상태 확인
    - echo "=== Checking downloaded artifacts ==="
    - ls -la
    - ls -la build/libs/ || echo "build/libs directory not found"
    - find . -name "*.jar" -type f
    - find . -name "application.yml" -type f

  script:
    - echo "Starting deployment process..."

    # 1) JAR 파일 찾기 (개선된 로직)
    - |
      # 먼저 예상 위치에서 찾기
      if [ -f "build/libs/performance-service-build.jar" ]; then
        echo "Found JAR at expected location"
        JAR_FILE="build/libs/performance-service-build.jar"
      else
        # build/libs/ 디렉토리에서 JAR 파일 찾기 (gradle-wrapper.jar 제외)
        JAR_FILE=$(find build/libs/ -name "*.jar" -type f | grep -v gradle-wrapper | head -1)
        if [ -n "$JAR_FILE" ] && [ -f "$JAR_FILE" ]; then
          echo "Found JAR file: $JAR_FILE"
        else
          echo "ERROR: No JAR file found in build/libs/!" >&2
          exit 1
        fi
      fi

    # 2) 기존 Dockerfile에 맞춰 JAR 파일명 변경
    - |
      # JAR 파일을 기존 Dockerfile이 기대하는 이름으로 복사
      cp "$JAR_FILE" performance-service-build.jar
      echo "Copied JAR file to: performance-service-build.jar"

    # 3) application.yml 확인
    - |
      if [ ! -f "application.yml" ]; then
        echo "ERROR: application.yml not found!" >&2
        exit 1
      fi

    # 4) 최종 파일 확인
    - echo "=== Final files check ==="
    - ls -la performance-service-build.jar application.yml

    # 5) 기존 Dockerfile로 Docker 이미지 빌드
    - docker build -t "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA" .

    # 6) GitLab 레지스트리 로그인 & 이미지 push
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
    - docker push "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"

    # 7) SSH 클라이언트 설치
    - |
      if command -v apk >/dev/null 2>&1; then
        apk add --no-cache openssh-client
      elif command -v apt-get >/dev/null 2>&1; then
        apt-get update && apt-get install -y openssh-client
      else
        echo "No supported package manager to install ssh client" >&2
        exit 1
      fi

    # 8) EC2 키 설정
    - mv "$EC2_PRIVATE_KEY" deploy_key.pem
    - chmod 600 deploy_key.pem

    # 9) 원격 배포 실행
    - |
      ssh -o StrictHostKeyChecking=no -i deploy_key.pem "$EC2_USER@$EC2_HOST" "
        echo '$CI_REGISTRY_PASSWORD' | docker login -u '$CI_REGISTRY_USER' --password-stdin '$CI_REGISTRY' &&
        echo 'Pulling image: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA' &&
        docker pull '$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA' &&
        export CI_REGISTRY_IMAGE='$CI_REGISTRY_IMAGE' &&
        export CI_COMMIT_SHORT_SHA='$CI_COMMIT_SHORT_SHA' &&
        echo 'Stopping existing containers...' &&
        docker-compose -f /home/$EC2_USER/docker-compose.yml down &&
        echo 'Starting new containers...' &&
        docker-compose -f /home/$EC2_USER/docker-compose.yml up -d &&
        echo 'Deployment completed successfully'
      "

    # 10) 정리
    - rm -f deploy_key.pem
    - echo "Deployment successful."

  only:
    - main